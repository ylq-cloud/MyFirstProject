数据库完整性：

正确有效相容性

约束状态：

静态：某一确定时刻的约束条件

动态：从一个状态转变为另一个状态过程中的约束条件



为了维护完整性 需要做的：

提供定义完整性约束的机制

提供检查方法

提供违约处理反方法





对象：

 属性上的约束条件 元组上的约束条件 用check  constraint命名子句





触发器create trigger sol

before after ......

        for each row

as begin

 if...

;

;

end if;

end;



drop trigger name on name





查询优化



查询处理的过程：

查询分析 查询检查 查询优化 查询执行



选择操作

全表扫描 索引扫描b+ hash

连接操作：

嵌套循环 排序合并 索引连接 hashjoin







优化的意义：最好的表达查询提高效率



查询优化的步骤，查询执行的代价：



查询优化的一般准则

关系代数式的优化算法

语法树及其优化























1、CREATE DATABASE MIS

2、CREATE TABLE 部门 (cno int(10) PRIMARY KEY,name char(15), num INT(20))

 





数据库恢复：

事务：恢复和并发控制的单位

transaction

acid

原子 一致 隔离 持续

故障种类：

事务内部 系统故障 介质故障

事务内部：代码  undo

系统故障：断电.. redo已完成 undo未完成

介质故障：磁盘损坏 日志+redo在此之前已完成的

计算机病毒 1、损坏数据库 2、未损坏数据库数据可能不正确



恢复技术：

建立冗余 利用冗余



如何建立：

数据转储 登录日志文件

数据转储：静态动态 海量 增量

静态：优点方便 缺点必须在事务未运行时进行转储 降低数据库并发性可用性

动态 优点可以随时转储 缺点数据可能会出错

海量 一次性将全部进行转储

增量 只转储新增的部分



检查点技术

减少搜索日志时间  改善恢复效率

定期不定期



数据库镜像：

自动复制关键数据或整个数据库

保证一致性

出现介质故障时不需要关闭系统和重装副本 dbms自动利用镜像数据进行恢复







并发控制：

串行 交叉并发 同时并发

丢失修改 不可重复读 读脏数据



丢失修改 两个事务同时修改 导致丢失

不可重复读 第一个事务读 第二个事务修改后 第一个事务读取的数据变了

读脏数据 ：事务rollback 导致其他事务读到的数据不具有持续性，数据不正确





并发控制的主要技术：

封锁 时间戳 乐观控制



x排他

s共享

is意向锁

ix six=s+ix



封锁协议：

一级封锁协议：修改前必须加x 直到事务结束

防止丢失修改

二级封锁协议 在一级基础上 读之前必须加s 读完释放

防止读脏数据

三级封锁协议 二级基础上 读之前加s 必须得事务结束后释放

防止不可重复读





活锁：无限等待   方法：先来先服务

死锁：互相请求 互相等待

预防死锁： 顺序加锁法 一次封锁法

一次封锁法：缺点 降低了并发度 难于确定封锁对象

顺序加锁法： 难维护 难确定



诊断死锁： 超时法 有向图法

超时判定死锁

有向图有环判定死锁



**解除死锁 ：选择一个代价最小的事务undo 释放此事务所有锁**



可串行化调度：

当其仅当结果和某一次串行执行一样

可串行化 才是正确调度



冲突可串行化能推可串行化

冲突可串行化 冲突操作次序不变的情况下，交换非冲突操作，如果是串行的就是可串行化调度



两段锁协议2pl 产生可串行化调度 只是充分条件

扩展阶段 收缩阶段

扩展：只能加锁 收缩只能释放锁





封锁粒度：

显式  直接加锁

隐式  上级节点被加锁

 加锁之前得 看上级 下级 该数据对象



意向锁 提高检查效率













数据库设计

关系模式问题：

冗余太大

更新 插入 删除异常

 范式的模式分解 ：规范化





delete from 表明 where 条件

